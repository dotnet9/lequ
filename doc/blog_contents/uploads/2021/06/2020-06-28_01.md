>仓库地址：https://github.com/dahall/Vanara
>
>翻译：沙漠尽头的浪(水平有限，如有条件请尽量查看仓库地址翻阅)

![](https://img1.lequ.co/2021/06/0101.png)

>一系列非常简单易用，对Windows API做了极好封装的.NET类库，几乎不用再写繁琐的Windows API转换函数了。

此项目包含各种.NET程序集，这些程序集包含来自Windows库的P/Invoke函数、接口、枚举和结构。每个程序集都与一个或几个紧密相关的库相关联。例如，Shlwapi.dll包含从Shlwapi.lib导出的所有函数；Kernel32.dll包含Kernel32.lib和kernelbase.lib的全部。

所有程序集都可通过NuGet获得，并提供针对.NET 2.0、3.5、4.0、4.5、Core 3.0、Core 3.1和.NET 5.0（v3.2.20中新增）的版本，并支持[SourceLink](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink)。在依赖项不允许的所有情况下，.NET Standard 2.0、.NET Core 2.0和2.1版本也包含在UWP和其他.NET Core及标准项目中。

在充分测试之后，这个项目每隔几周发布一次新版本。新的版本和发行说明一起被编目在[Releases](https://github.com/dahall/Vanara/releases)部分，所有NuGet包都发布到[nuget.org](https://www.nuget.org/packages?q=dahall+Vanara)。每个GitHub推送都会触发[AppVeyor](https://ci.appveyor.com/project/dahall/vanara)构建。所有者感谢他们的免费开源帐户！文章开头显示了项目构建状态信息。[AppVeyor源](https://ci.appveyor.com/nuget/vanara-prerelease)用于构建NuGet包。

## 怎么用？

1. 在Microsoft文档中查找所需的函数。请注意函数位于哪个库或DLL中。
2. 查看下面的支持库表，确认Vanara库存在并具有您需要的函数(Windows API)。单击程序集链接将带您深入了解该程序集的覆盖范围。找到你的函数，如果有一个匹配的实现，它会出现在右边。您还可以使用GitHub的项目搜索（页面左上角）来搜索函数、方法或常量。确保选择“在此存储库中”。
3. 通过NuGet将程序集添加到项目中。
4. 要使用该功能，您可以：
- 1. 直接调用`var bret = Vanara.PInvoke.Kernel32.GetComputerName(sb, ref sbSz);`
- 2. 在C#6.0及更高版本下，使用static using指令并调用它：

```C#
using static Vanara.PInvoke.Kernel32;

var bret = GetComputerName(sb, ref sbSz);
```

5.在某些情况下，其中一个[支持程序集]中有一个对应的helper/wrapper类，特别是对于安全性、系统服务、窗体和Shell。转到他们的库页面（单击部分中的链接），浏览每个库中包含的类。

## 设计理念

- 从单个DLL导入的所有函数都应放置到以DLL命名的单个程序集中。
  - （例如，程序集`Vanara.PInvoke.Gdi32.dll`承载系统目录中从`gdi32.dll`导出的所有函数和支持的枚举、常量和结构。）
- 任何由许多库使用的结构、宏或枚举（非函数）都会放入`Vanara.Core`或'Vanara.PInvoke.Shared`库中。
  - （例如，宏`HIWORD'和结构`SIZE`都在`Vanara.PInvoke.Shared`中，简化互操作调用和本机内存管理的类都在'Vanara.Core`中）
- 在项目中，所有构造都包含在一个以头文件（*.h）命名的文件中，其中这些结构在Windows API中定义。
  - （例如，在`Vanara.PInvoke.Kernel32`项目目录中，您将分别找到一个FileApi.cs、WinBase.cs和一个WinNT.cs文件，分别表示FileApi.h、WinBase.h和WinNT.h）
- 如果直接解释结构或函数会导致内存泄漏或误用，我试图简化它的使用。
- 在结构体总是通过引用传递，并且在需要清理内存分配的地方，我将结构体更改为实现`IDispoable`的类。
- 尽可能，所有句柄都已转换为以Windows API句柄命名的`SafeHandle`派生工具。如果这些句柄需要调用函数以释放/关闭/销毁，则存在一个派生的`SafeHANDLE`，该函数将在disposal时执行该函数。
  - 例如，定义了`HTOKEN`。 `SafeHTOKEN`在该句柄上调用`CloseHandle`自动释放。
- 尽可能，分配调用方释放的内存的所有函数都使用安全的内存句柄。
- 程序集中所有PInvoke调用都以'Vanara.PInvoke`为前缀。
- 如果要将结构体作为常量传递到函数中，则使用`in`语句封装该结构体，该语句将通过引用传递结构体，而不需要`ref`关键字。
  - Windows API:`BOOL MapDialogRect(HWND hDlg, LPRECT LPRECT)`
  - Vanara:`bool MapDialogRect(HWND hDlg, in RECT lpRect);`
- 如果有类或扩展使用PInvoke调用，则它们位于以'Vanara'前缀的包装程序集中，然后后跟该功能的逻辑名称。今天，它们是Core、Security、SystemServices、Windows.Forms和Windows.Shell。

## 支持的库

![](https://img1.lequ.co/2021/06/0102.png)

![](https://img1.lequ.co/2021/06/0103.png)

![](https://img1.lequ.co/2021/06/0104.png)

![](https://img1.lequ.co/2021/06/0105.png)

![](https://img1.lequ.co/2021/06/0106.png)

## 支持的程序集

![](https://img1.lequ.co/2021/06/0107.png)

## 链接
* [Documentation](https://github.com/dahall/Vanara/wiki)
* [Issues](https://github.com/dahall/Vanara/issues)

## 示例代码

There are numerous examples in the [UnitTest](https://github.com/dahall/Vanara/tree/master/UnitTests) folder and in the [WinClassicSamplesCS](https://github.com/dahall/WinClassicSamplesCS) project that recreates the Windows Samples in C# using Vanara.
